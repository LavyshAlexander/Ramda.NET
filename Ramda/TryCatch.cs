// <autogenerated>
//   This file was generated by T4 code generator TryCatch.tt.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

using System;
using System.Dynamic;
using System.Collections;
using System.Threading.Tasks;
using static Ramda.NET.Currying;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Ramda.NET
{
	public static partial class R
	{	
		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(Delegate tryer, Delegate catcher) {
			return Currying.TryCatch(Delegate(tryer), Delegate(catcher));
		}

		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(RamdaPlaceholder tryer, Delegate catcher) {
			return Currying.TryCatch(tryer, Delegate(catcher));
		}

		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(Delegate tryer, RamdaPlaceholder catcher = null) {
			return Currying.TryCatch(Delegate(tryer), catcher);
		}

		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(RamdaPlaceholder tryer, dynamic catcher) {
			return Currying.TryCatch(tryer, Delegate(catcher));
		}

		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(dynamic tryer, RamdaPlaceholder catcher = null) {
			return Currying.TryCatch(Delegate(tryer), catcher);
		}

		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(dynamic tryer, Delegate catcher) {
			return Currying.TryCatch(Delegate(tryer), Delegate(catcher));
		}

		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(Delegate tryer, dynamic catcher) {
			return Currying.TryCatch(Delegate(tryer), Delegate(catcher));
		}

		/// <summary>
		/// `tryCatch` takes two functions, a `tryer` and a `catcher`. The returnedfunction evaluates the `tryer`; if it does not throw, it simply returns theresult. If the `tryer` *does* throw, the returned function evaluates the`catcher` function and returns its result. Note that for effectivecomposition with this function, both the `tryer` and `catcher` functionsmust return the same type of results.
		/// <para />
		/// sig: (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
		/// </summary>
		/// <param name="tryer">The function that may throw.</param>
		/// <param name="catcher">The function that will be evaluated if `tryer` throws.</param>
		/// <returns>A new function that will catch exceptions and send then to the catcher.</returns>
		public static dynamic TryCatch(RamdaPlaceholder tryer = null, RamdaPlaceholder catcher = null) {
			return Currying.TryCatch(tryer, catcher);
		}
	}
}
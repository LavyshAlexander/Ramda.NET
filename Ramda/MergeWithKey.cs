// <autogenerated>
//   This file was generated by T4 code generator MergeWithKey.tt.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

using System;
using System.Dynamic;
using System.Collections;
using System.Threading.Tasks;
using static Ramda.NET.Currying;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Ramda.NET
{
	public static partial class R
	{	
		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey<TArg1, TArg2, TResult>(Func<string, TArg1, TArg2, TResult> fn, object l, object r) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey(RamdaPlaceholder fn, object l, object r) {
			return Currying.MergeWithKey(fn, l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey<TArg1, TArg2, TResult>(Func<string, TArg1, TArg2, TResult> fn, RamdaPlaceholder l, object r) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey<TArg1, TArg2, TResult>(Func<string, TArg1, TArg2, TResult> fn, object l, RamdaPlaceholder r = null) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey<TArg1, TArg2, TResult>(Func<string, TArg1, TArg2, TResult> fn, RamdaPlaceholder l = null, RamdaPlaceholder r = null) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey(dynamic fn, RamdaPlaceholder l, object r) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey(dynamic fn, object l, RamdaPlaceholder r = null) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey(dynamic fn, RamdaPlaceholder l = null, RamdaPlaceholder r = null) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey(dynamic fn, object l, object r) {
			return Currying.MergeWithKey(Delegate(fn), l, r);
		}

		/// <summary>
		/// Creates a new object with the own properties of the two provided objects. Ifa key exists in both objects, the provided function is applied to the keyand the values associated with the key in each object, with the result beingused as the value associated with the key in the returned object. The keywill be excluded from the returned object if the resulting value is`undefined`.
		/// <para />
		/// sig: (String -> a -> a -> a) -> {a} -> {a} -> {a}
		/// </summary>
		/// <param name="fn">first</param>
		/// <param name="l">second</param>
		/// <param name="r">third</param>
		/// <returns>Object</returns>
		/// <see cref="R.Merge"/>
		/// <see cref="R.MergeWith"/>
		public static dynamic MergeWithKey(RamdaPlaceholder fn = null, RamdaPlaceholder l = null, RamdaPlaceholder r = null) {
			return Currying.MergeWithKey(fn, l, r);
		}
	}
}
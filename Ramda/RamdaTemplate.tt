<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="T4Toolbox.tt" #><#+
public class RamdaTemplate : CSharpTemplate
{		
	private readonly string name;
	
	public RamdaTemplate() {
		Generics = new List<string>();
		Emitted = new HashSet<string>();
		Parameters = new List<Tuple<string, string, bool>>();
		name = Path.GetFileNameWithoutExtension(TransformationContext.Current.Host.TemplateFile).Split('.')[0];
	}

	public List<string> Generics { get; set; }

	private HashSet<string> Emitted { get; set; }
	
	public bool AllGapsFunctionAlreadyExists { get; set; }
	
	public List<Tuple<string, string, bool>> Parameters { get; set; }

	private string FormatTuple(Tuple<string, string, bool> tuple) {
		return string.Format("{0} {1}", tuple.Item1, tuple.Item2);
	}

	private string ResolveGenerics(List<string> generics) {
		return generics.Count > 0 ? "<" + string.Join(", ", generics) + ">" : "";
	}

	private bool FillPlaceholders(List<Tuple<string, string, bool>> tuples, int index) {
        bool hasDynamic = false;

        for (int i = tuples.Count - 1; i >= 0; i--) {
            var tuple = tuples[i];

            if (tuple.Item3 && i == index) {
                hasDynamic = true;
            }
			else if (hasDynamic) {
                tuples[i] = FillPlaceholder(tuple);
				
			}
			else {
                tuples[i] = FillNullablePlaceholder(tuple);
			}
        }

		return hasDynamic;
    }

	private bool TryGetDynamicParameters(List<Tuple<string, string, bool>> tuples) {
        bool hasDynamic = false;

        for (int i = 0; i < tuples.Count; i++) {
            var tuple = tuples[i];

            if (tuple.Item3) {
                hasDynamic = true;

                tuples[i] = Tuple.Create("dynamic", tuple.Item2, true);
            }
        }

        return hasDynamic;
    }

	private string ResolveGenerics(IEnumerable<Tuple<string, string, bool>> tuples) {
		var hash = new HashSet<string>();
        var generics = new List<string>();
        var types = tuples.Select(tuple => tuple.Item1).ToList();

        types.ForEach(type => {
            var generic = Generics.SingleOrDefault(g => type.IndexOf(g) > -1);

            if (generic != null && hash.Add(generic)) {
                generics.Add(generic);
            }
        });

        return ResolveGenerics(generics);
	}

	private bool TupleEquals(Tuple<string, string, bool> first, Tuple<string, string, bool> second) {
		return first.Item1.Equals(second.Item1) && first.Item2.Equals(second.Item2) && first.Item3.Equals(second.Item3);
	}

	private bool SequenceEquals(List<Tuple<string, string, bool>> first, List<Tuple<string, string, bool>> second) {
		if (first.Count != second.Count) {
			return false;
		}

		for (var i = 0; i < first.Count; i++) {
			if (!TupleEquals(first[i], second[i])) {
				return false;
			}
		}

		return true;
	}

	private string Join(IEnumerable<Tuple<string, string, bool>> joined) {
		return string.Join(", ", joined.Select(FormatTuple)); 
	}

	private Tuple<string, string, bool> FillPlaceholder(Tuple<string, string, bool> tuple) {
		
		return Tuple.Create("RamdaPlaceholder", tuple.Item2, false);
	}

	private Tuple<string, string, bool> FillNullablePlaceholder(Tuple<string, string, bool> tuple) {
		
		return Tuple.Create("RamdaPlaceholder", string.Format("{0} = null", tuple.Item2), false);
	}

	public override string TransformText() {
		base.TransformText();
#>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Ramda.NET
{
	public static partial class R
	{	
<#+		var generics = ResolveGenerics(Generics);
		var parameterNames = string.Join(", ", Parameters.Select(t => t.Item2));
		var parametersWithDynamic = Parameters.ToList();

		if (TryGetDynamicParameters(parametersWithDynamic)) {
			var joined = Join(parametersWithDynamic);
			
			Emitted.Add(joined); #>
		public static dynamic <#= name #><#= ResolveGenerics(parametersWithDynamic) #>(<#= joined #>) {
			return Currying.<#= name #>(<#= parameterNames #>);
		}
			
<#+		}
#>
		public static dynamic <#= name #><#= generics #>(<#= Join(Parameters) #>) {
			return Currying.<#= name #>(<#= parameterNames #>);
		}
<#+		for (var i = 0; i < Parameters.Count; i++)	 {
			var hasDynamic = false;
			var hasShiftedDynamic = false;
			var shifted = Parameters.ToList();
			var shiftedItem = Parameters[i];
			Tuple<string, string, bool> insertee;
			List<Tuple<string, string, bool>> shiftedDynamics;
			List<Tuple<string, string, bool>> dynamicsWithPlaceHolders = null;
			
			dynamicsWithPlaceHolders = shifted.ToList();
			shifted.RemoveAt(i);
			shiftedDynamics = shifted.ToList();
			
			if (TryGetDynamicParameters(shiftedDynamics)) {
				hasShiftedDynamic = true;
			}

			if (TryGetDynamicParameters(dynamicsWithPlaceHolders)) {
				hasDynamic = FillPlaceholders(dynamicsWithPlaceHolders, i);
			}

			insertee = i == Parameters.Count - 1 ? FillNullablePlaceholder(shiftedItem) : FillPlaceholder(shiftedItem);
			shiftedDynamics.Insert(i, insertee);
			shifted.Insert(i, insertee); 
			
			if (!AllGapsFunctionAlreadyExists || Parameters.Count > 1) {
				if (hasDynamic) {
					var joined = Join(dynamicsWithPlaceHolders);
					
					if (!Emitted.Contains(joined)) { #>
		
		public static dynamic <#= name #>(<#= joined #>) {
			return Currying.<#= name #>(<#= parameterNames #>);
		}
<#+						Emitted.Add(joined);
					}
				}
				if (hasShiftedDynamic && !SequenceEquals(shiftedDynamics, dynamicsWithPlaceHolders)) {
					var joined = Join(shiftedDynamics);
					
					if (!Emitted.Contains(joined)) { #>

		public static dynamic <#= name #><#= ResolveGenerics(shiftedDynamics) #>(<#= joined #>) {
			return Currying.<#= name #>(<#= parameterNames #>);//
		}
				
<#+						Emitted.Add(joined);
					}
				}
#>		
		public static dynamic <#= name #><#= generics #>(<#= Join(shifted) #>) {
			return Currying.<#= name #>(<#= parameterNames #>); 
		}
<#+        }
   }
		for (var i = 1; i < Parameters.Count - 1; i++)	 {
			var taken = Parameters.Take(i);
			var skipped = Parameters.Skip(i);
			var rightFilled = string.Join(", ", taken.Concat(skipped.Select(FillNullablePlaceholder)).Select(FormatTuple)); #>		
		
		public static dynamic <#= name #><#= generics #>(<#= rightFilled #>) {
			return Currying.<#= name #>(<#= parameterNames #>);
		}
<#+		}
		if (!AllGapsFunctionAlreadyExists && Parameters.Count > 1) {	#>
		
		public static dynamic <#= name #><#= generics #>(<#= string.Join(", ", Parameters.Select(FillNullablePlaceholder).Select(FormatTuple)) #>) {
			return Currying.<#= name #>(<#= parameterNames #>);
		}
<#+}#>
	}
}
<#+
        return this.GenerationEnvironment.ToString();
	}
}
#>

<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="T4Toolbox.tt" #><#+
public class RamdaTemplate : CSharpTemplate
{		
	private readonly string name;
	
	public RamdaTemplate() {
		Generics = new List<string>();
		Emitted = new HashSet<string>();
		SkippedIndexedGaps = new List<int>();
		Parameters = new List<Tuple<string, string, bool>>();
		name = Path.GetFileNameWithoutExtension(TransformationContext.Current.Host.TemplateFile).Split('.')[0];
	}

	public List<string> Generics { get; set; }

	private HashSet<string> Emitted { get; set; }

	public List<int> SkippedIndexedGaps { get; set; }
	
	public bool AllGapsFunctionAlreadyExists { get; set; }
	
	public List<Tuple<string, string, bool>> Parameters { get; set; }

	private string FormatTuple(Tuple<string, string, bool> tuple) {
		return string.Format("{0} {1}", tuple.Item1, tuple.Item2);
	}

	private string ResolveGenerics(List<string> generics) {
		return generics.Count > 0 ? "<" + string.Join(", ", generics) + ">" : "";
	}

	private bool FillPlaceholders(List<Tuple<string, string, bool>> tuples, int index) {
        bool hasDynamic = false;

        for (int i = tuples.Count - 1; i >= 0; i--) {
            var tuple = tuples[i];

            if (tuple.Item3 && i == index) {
                hasDynamic = true;
            }
			else if (hasDynamic) {
                tuples[i] = FillPlaceholder(tuple);
				
			}
			else {
                tuples[i] = FillNullablePlaceholder(tuple);
			}
        }

		return hasDynamic;
    }

	private bool TryGetDynamicParameters(List<Tuple<string, string, bool>> tuples, int? index = null) {
        bool hasDynamic = false;

        for (int i = 0; i < tuples.Count; i++) {
            var tuple = tuples[i];

            if (tuple.Item3) {
				if ((index != null && i == index) || index == null) {
					hasDynamic = true;

					tuples[i] = Tuple.Create("dynamic", tuple.Item2, true);
				}

				if (hasDynamic && index != null) {
					break;
				}
            }
        }

        return hasDynamic;
    }

	private List<int> TryGetDynamicIndexes(List<Tuple<string, string, bool>> tuples) {
        var list = new List<int>();

        for (int i = 0; i < tuples.Count; i++) {
            var tuple = tuples[i];

            if (tuple.Item3) {
                list.Add(i);
            }
        }

        return list;
    }

	private string ResolveGenerics(IEnumerable<Tuple<string, string, bool>> tuples) {
		var hash = new HashSet<string>();
        var generics = new List<string>();
		var sorted = new List<string>();
        
        var types = tuples.Select(tuple => tuple.Item1).ToList();

        types.ForEach(type => {
			var filteredGenerics = Generics.Where(g => type.IndexOf(g) > -1).ToList();

			filteredGenerics.ForEach(generic => {
				if (generic != null && hash.Add(generic)) {
					generics.Add(generic);
				}
			});
        });

		Generics.ForEach(generic => {
			if (generics.Contains(generic)) {
				sorted.Add(generic);
			}
		});

		return ResolveGenerics(sorted);
	}

	private bool TupleEquals(Tuple<string, string, bool> first, Tuple<string, string, bool> second) {
		return first.Item1.Equals(second.Item1) && first.Item2.Equals(second.Item2) && first.Item3.Equals(second.Item3);
	}

	private bool SequenceEquals(List<Tuple<string, string, bool>> first, List<Tuple<string, string, bool>> second) {
		if (first.Count != second.Count) {
			return false;
		}

		for (var i = 0; i < first.Count; i++) {
			if (!TupleEquals(first[i], second[i])) {
				return false;
			}
		}

		return true;
	}

	private string Join(IEnumerable<Tuple<string, string, bool>> joined) {
		return string.Join(", ", joined.Select(FormatTuple)); 
	}

	private Tuple<string, string, bool> FillPlaceholder(Tuple<string, string, bool> tuple) {
		
		return Tuple.Create("RamdaPlaceholder", tuple.Item2, false);
	}

	private Tuple<string, string, bool> FillNullablePlaceholder(Tuple<string, string, bool> tuple) {
		
		return Tuple.Create("RamdaPlaceholder", string.Format("{0} = null", tuple.Item2), false);
	}

	private string ToArguments(List<Tuple<string, string, bool>> tuples) {
		var list = new List<string>();

		for (int i = 0; i < tuples.Count; i++) {
			var tuple = tuples[i];
			var name = tuple.Item2.Replace(" = null", "");

			if (tuple.Item3) {
				list.Add(string.Format("Delegate({0})", name));
			}
			else {
				list.Add(name);
			}
		}

		return string.Join(", ", list);
	}

	private void Emit(List<Tuple<string, string, bool>> list, string name) {
		for (var i = 0; i < list.Count; i++)	 {
			if (SkippedIndexedGaps.Contains(i)) {
				continue;
			}

			string joined;
			var shifted = list.ToList();
			var shiftedItem = list[i];
			
			shifted.RemoveAt(i);
			shifted.Insert(i, i == Parameters.Count - 1 ? FillNullablePlaceholder(shiftedItem) : FillPlaceholder(shiftedItem)); 
			joined = Join(shifted);

			if (!AllGapsFunctionAlreadyExists || Parameters.Count > 1) {
				Emit(name, ResolveGenerics(shifted), joined, ToArguments(shifted));
			}
        }

		for (var i = 1; i < list.Count - 1; i++)	 {
			var taken = list.Take(i);
			var skipped = list.Skip(i);
			var joined = taken.Concat(skipped.Select(FillNullablePlaceholder)).ToList();
			var rightFilled = string.Join(", ", joined.Select(FormatTuple));		
			
			Emit(name, ResolveGenerics(joined), rightFilled, ToArguments(joined));
		}
	}

	private void Emit(string name, string generics, string parameters, string arguments, bool addNewLine = true) {
		if (!Emitted.Contains(parameters)) {
			if (addNewLine) {
				WriteLine("");
			}#>
		public static dynamic <#= name #><#= generics #>(<#= parameters #>) {
			return Currying.<#= name #>(<#= arguments #>);
		}
<#+			Emitted.Add(parameters);
		}
	}

	private string GenerateDynamicArguments(List<Tuple<string, string, bool>> dynamics) {
		return string.Join(", ", dynamics.Select(d => d.Item1.Equals("dynamic") ? string.Format("Delegate({0})", d.Item2) : d.Item2));
	}

	public override string TransformText() {
		base.TransformText();
#>
using System;
using System.Dynamic;
using System.Collections;
using static Ramda.NET.Currying;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Ramda.NET
{
	public static partial class R
	{	
<#+		
		var dynamics = Parameters.ToList();
		var generics = Generics.Count > 0 ? "<" + string.Join(", ", Generics) + ">" : "";
		var arguments = string.Join(", ", Parameters.Select(t => t.Item2));

		Emit(name, generics, Join(Parameters), ToArguments(Parameters), false);
		Emit(Parameters.ToList(), name);
		
		if (TryGetDynamicParameters(dynamics)) {
			var indexes = TryGetDynamicIndexes(dynamics);
			
			Emit(dynamics, name);

			indexes.ForEach(i => {
				dynamics = Parameters.ToList();

				if (TryGetDynamicParameters(dynamics, i)) {
					var joined = string.Join(", ", dynamics.Select(FormatTuple));

					Emit(name, ResolveGenerics(dynamics), joined, GenerateDynamicArguments(dynamics));
				}
			});
		}
		
		if (!AllGapsFunctionAlreadyExists && Parameters.Count > 1) {
			Emit(name, string.Empty, string.Join(", ", Parameters.Select(FillNullablePlaceholder).Select(FormatTuple)), arguments);
		}#>
	}
}
<#+
        return this.GenerationEnvironment.ToString();
	}
}
#>